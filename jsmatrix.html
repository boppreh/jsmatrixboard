<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width" />
        <title>Matrix Board Test</title>
        <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font: 16px sans-serif;
            color: #CCC;
        }
        canvas {
            background-color: #EEE;
            width: 100%;
            height: 100%;
            background-color: #456990;
        }
        </style>
    </head>
    <body>
        <canvas></canvas>
        <script>
"use strict";

var Cell = function(row, col, type, primarySelection, secondarySelection) {
    this.row = row;
    this.col = col;
    this.type = type;
    this.primarySelection = primarySelection;
    this.secondarySelection = secondarySelection;
}

var Matrix = function(width, height, canvas, autoResize, ctrlZ) {
    this.width = width;
    this.height = height || width;
    this.clear(1);

    this.canvas = canvas || document.getElementsByTagName('canvas')[0];
    this.context = this.canvas.getContext('2d');

    this.fillStyles = {0: 'none', 1: '#156615', 2: '#CC3333', 3: '#33DD33'};
    this.selectionStyle = {0: 'none', 1: 'rgb(220, 220, 220)', 2: 'rgba(220, 220, 220, 0.2)'};
    this.borderStyle = '#CCC';

    var self = this;

    if (autoResize === undefined || autoResize) {
        this.resize();
        window.onresize = function() {
            self.resize();
            self.updateDimensions();
            self.render(self.board);
        };
    }

    this.history = [];
    this.future = [];
    if (ctrlZ === undefined || ctrlZ) {
        document.addEventListener('keydown', function(e) {
            if (e.keyCode === 90 && e.ctrlKey) {
                if (e.shiftKey) {
                    self.redo();
                } else {
                    self.undo();
                }
                self.render();
            }
        });
    }

    this.lastMovement = [null, null];
    this.translateEventListener('onmousemove');
    this.translateEventListener('onmousedown');
    this.translateEventListener('onmouseup');
    this.translateEventListener('onclick');

    this.updateDimensions();
    setTimeout(this.render.bind(this), 1);

    this.debug = {};
};

Matrix.prototype.translateEventListener = function(eventName) {
    var self = this;
    this.canvas[eventName] = function(e) {
        if (self[eventName]) {
            e.col = self.xToCol(e.clientX);
            e.row = self.yToRow(e.clientY);
            e.cell = self.isValid(e.row, e.col) ? self.board[e.row][e.col] : undefined;
            if (eventName == 'onmousemove') {
                if (e.row == self.lastMovement[0] && e.col == self.lastMovement[1]) {
                    return;
                } else {
                    self.lastMovement = [e.row, e.col];
                }
            }
            self[eventName](e);
            self.render();
        }
    };
}

Matrix.prototype.isValid = function(row, col) {
    return row >= 0 && row < this.height && col >= 0 && col < this.height;
};

Matrix.prototype.xToCol = function(x) {
    return Math.round((x - this.canvas.width/2) / this.cellSpace + this.width/2 - 0.5);
};

Matrix.prototype.yToRow = function(y) {
    return Math.round((y - this.canvasPadding) / this.cellSpace - 0.5);
};

Matrix.prototype.resize = function() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
};

Matrix.prototype.updateDimensions = function() {
    this.width = this.board[0].length;
    this.height = this.board.length;

    this.canvasPadding = this.canvas.height / 20;
    this.cellSpace = Math.min((this.canvas.width - 2*this.canvasPadding) / this.width, (this.canvas.height - 2*this.canvasPadding) / this.height);
    if (this.cellSpace > 10) {
        this.cellPadding = Math.max(1, this.cellSpace / 20);
    } else {
        this.cellPadding = 0;
    }
    this.cellBorder = this.cellSpace / 5;
    this.cellSize = this.cellSpace - this.cellPadding * 2;
};

Matrix.prototype.render = function () {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    this.context.save();
    for (var col = 0; col < this.width; col++) {
        var x = this.canvas.width/2 + (col-this.width/2)*this.cellSpace;

        for (var row = 0; row < this.height; row++) {
            var y = this.canvasPadding + row * this.cellSpace;

            var cell = this.board[row][col];
            if (cell.type !== 0) {
                var fillStyle = this.fillStyles[cell.type];
                
                this.context.fillStyle = fillStyle;
                this.context.fillRect(x + this.cellPadding, y,
                                 this.cellSize, this.cellSize);
                if (this.cellSpace > 10) {
                    this.context.strokeStyle = this.borderStyle;
                    this.context.strokeRect(x + this.cellPadding, y,
                                       this.cellSize, this.cellSize);
                }
            }

            if (cell.primarySelection) {
                this.context.fillStyle = this.selectionStyle[cell.primarySelection];
                this.context.beginPath();
                this.context.moveTo(x+this.cellBorder+this.cellPadding, y+this.cellBorder);
                this.context.lineTo(x+this.cellSize-this.cellBorder+this.cellPadding, y+this.cellBorder);
                this.context.lineTo(x+this.cellBorder+this.cellPadding, y+this.cellSize-this.cellBorder);
                this.context.fill();
            }
            if (cell.secondarySelection) {
                this.context.fillStyle = this.selectionStyle[cell.secondarySelection];
                this.context.beginPath();
                this.context.moveTo(x+this.cellPadding+this.cellSize-this.cellBorder, y+this.cellSize-this.cellBorder);
                this.context.lineTo(x+this.cellPadding+this.cellSize-this.cellBorder, y+this.cellBorder);
                this.context.lineTo(x+this.cellPadding+this.cellBorder, y+this.cellSize-this.cellBorder);
                this.context.fill();
            }
        }
    }
    this.context.restore();

    this.context.save();
    this.context.fillStyle = '#CCC';
    this.context.font = '16px Verdana';
    this.context.textAlign = 'right';
    var yStart = 20;
    var xStart = this.canvas.width - 10;
    for (var prop in this.debug) {
        this.context.fillText(prop + ": " + this.debug[prop], xStart, yStart);
        yStart += 20;
    }
    this.context.restore();
};

Matrix.prototype.forEach = function(fn) {
    for (var row = 0; row < this.height; row++) {
        for (var col = 0; col < this.width; col++) {
            fn(this.board[row][col]);
        }
    }
};

Matrix.prototype.clear = function(defaultType) {
    this.board = [];
    defaultType = defaultType === undefined ? 0 : defaultType;
    for (var row = 0; row < this.height; row++) {
        var line = [];
        this.board.push(line);
        for (var col = 0; col < this.width; col++) {
            line.push(new Cell(row, col, defaultType));
        }
    }
};

Matrix.prototype.clearSelection = function() {
    this.forEach(function(cell) {
        cell.primarySelection = 0;
        cell.secondarySelection = 0;
    });
};

Matrix.prototype.save = function() {
    var backup = [];
    for (var row = 0; row < this.height; row++) {
        var line = [];
        backup.push(line);
        for (var col = 0; col < this.width; col++) {
            var backupCell = new Cell();
            var cell = this.board[row][col];
            for (var prop in cell) {
                backupCell[prop] = cell[prop];
            }
            line.push(backupCell);
        }
    }

    this.history.push(backup);
    this.future = [];
};

Matrix.prototype.undo = function() {
    if (this.history.length) {
        this.future.push(this.board);
        this.board = this.history.pop();
    } else {
        throw "No more history available for undo.";
    }
};

Matrix.prototype.redo = function() {
    if (this.future.length) {
        this.history.push(this.board);
        this.board = this.future.pop();
    } else {
        throw "No more history available for redo.";
    }    
};
        </script>
        <script>
var Model = function(coeffs) {
    coeffs.sort(function(a,b){return b - a});
	this.coeffs = coeffs;
}

Model.prototype.isCorrect = function(row, col) {
    var m = this.coeffs[0];
    var a = this.coeffs[1];

    var xored;
    for (var i = 0; i < this.coeffs.length; i++) {
        var cola = col - this.coeffs[i];
        xored ^= cola >= 0 && row >= cola && (row - cola) % (m - a) === 0;
	}
    
    return xored;
}

Model.prototype.show = function(matrix) {
    matrix.debug['cellCount'] = 0;
    var m = this.coeffs[0];
    matrix.forEach(function(cell) {
        if (cell.col < m && model.isCorrect(cell.row, cell.col)) {
            matrix.debug['cellCount']++;
            cell.type = 1;
        } else {
            cell.type = 0;
        }
    });
    matrix.render();
}

var hash = window.location.hash;
var coeffs;
if (hash) {
    coeffs = window.location.hash.slice(1).split(',').map(Number);
} else {
    coeffs = [100, 5, 4, 3];
}
var model = new Model(coeffs);

var matrix;
function createMatrix() {
    matrix = new Matrix(model.coeffs[0]*2, model.coeffs[0]-1);
    matrix.debug.count = 0;
    model.show(matrix);
}
createMatrix();


var selectedCoeff = 1;
document.onwheel = function(e) {
    var delta = (e.deltaY || e.deltaX) < 0 ? 1 : -1;
    if (e.shiftKey) {
        selectedCoeff = Math.min(Math.max(0, selectedCoeff - delta), model.coeffs.length - 1);
    } else {
        var n = model.coeffs[selectedCoeff] + delta;
        var lowerBound = model.coeffs[selectedCoeff+1] + 1 || 0;
        var upperBound = model.coeffs[selectedCoeff-1] - 1 || Infinity;
        model.coeffs[selectedCoeff] = Math.min(Math.max(n, lowerBound), upperBound);
        if (selectedCoeff === 0) {
            createMatrix();
        }
    }
    var letters = "mabcdefghijkl";
    var debug = {};
    for (var i = 0; i < model.coeffs.length; i++) {
        if (i === selectedCoeff) {
            debug['*' + letters[i]] = model.coeffs[i];
        } else {
            debug[letters[i]] = model.coeffs[i];
        }
        
    }
    matrix.debug = debug;
    model.show(matrix);
}

var selectionStart = null;
var selectionEnd = null;
var selectionCurrent = null;
matrix.onmousedown = function(e) {
    if (selectionStart !== null && selectionEnd !== null) {
        matrix.clearSelection();
        matrix.save();
        matrix.forEach(function(cell) {
            if (cell.willActivate) {
                cell.type = model.isCorrect(cell.row, cell.col) ? 3 : 2;
            } else {
                cell.type = model.isCorrect(cell.row, cell.col) ? 1 : 0;
            }
        });
        if (!e.shiftKey) {
            selectionStart = null;
            selectionEnd = null;
        }
        matrix.debug['count']++;
    } else {
        selectionStart = e.col;
        selectionEnd = null;
    }
    updateSelection();
}
matrix.onmousemove = function(e) {
    selectionCurrent = e.col;
    updateSelection();
}
matrix.onmouseup = function(e) {
    selectionEnd = selectionCurrent;
    updateSelection();
}
function updateSelection() {
    if (selectionStart === null) {
        return;
    }

    var end = selectionEnd === null ? selectionCurrent : selectionEnd;
    var selectionDistance = selectionEnd - selectionStart;
    matrix.forEach(function(cell) {
        if (cell.col >= Math.min(selectionStart, end) && cell.col <= Math.max(selectionStart, end)) {
            cell.primarySelection = (cell.type <= 1) ? 2 : 1;
        } else {
            cell.primarySelection = 0;
        }

        var src = matrix.board[cell.row][cell.col - (selectionCurrent - selectionEnd)];
        if (selectionEnd !== null && src && src.primarySelection) {
            cell.secondarySelection = src.primarySelection;
            cell.willActivate = cell.type >= 2 ^ src.type >= 2;
        } else {
            cell.secondarySelection = 0;
            cell.willActivate = cell.type >= 2;
        }
    });
}
        </script>
    </body>
</html>
