<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <title>Matrix Board Test</title>
        <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font: 16px sans-serif;
            color: #CCC;
        }
        canvas {
            background-color: #EEE;
            width: 100%;
            height: 100%;
            background-color: #456990;
        }
        #input-div {
            padding: 10px;
            position: fixed;
            background-color: #426487;
            display: flex;
            flex-direction: column;
            /*visibility: hidden;*/
        }
        </style>
    </head>
    <body>
        <div id="input-div">
            <textarea cols=30 rows=10 id="user-algorithm"></textarea>
            <div id="start-controls">
                <button onclick="runUserAlgorithm();">Apply</button>
            </div>
            <div id="running-controls" style="display: none;">
                <button id="btn-play-pause" onclick="playPauseUserAlgorithm();">Pause</button>
                <button onclick="running = true; stepUserAlgorithm(); running=false;">Step</button>
                <button onclick="stopUserAlgorithm();">Stop</button>
            </div>
        </div>
        <canvas></canvas>
        <script>
"use strict";
var canvas = document.getElementsByTagName('canvas')[0];

var Cell = function(row, col, type, background, primarySelection, secondarySelection) {
    this.row = row || 0;
    this.col = col || 0;
    this.type = type || 0;
    this.background = background || 0;
    this.primarySelection = primarySelection || 0;
    this.secondarySelection = secondarySelection || 0;
}

var Matrix = function(width, height, canvas, autoResize, ctrlZ) {
    this.width = width;
    this.height = height || width;
    this.clear(1);

    this.canvas = canvas || document.getElementsByTagName('canvas')[0];
    this.context = this.canvas.getContext('2d');

    this.fillStyles = {0: 'none', 1: '#33DD33', 2: '#459990', 3: '#CC3333'};
    this.backgrounds = {0: 'none', 1: '#426687'};
    this.selectionStyle = {0: 'none', 1: 'rgb(220, 220, 220)', 2: 'rgba(220, 220, 220, 0.2)'};
    this.borderStyle = '#CCC';

    var self = this;

    if (autoResize === undefined || autoResize) {
        this.resize();
        window.onresize = function() {
            self.resize();
            self.updateDimensions();
            self.render(self.board);
        };
    }

    this.history = [];
    this.future = [];
    if (ctrlZ === undefined || ctrlZ) {
        this.canvas.addEventListener('keydown', function(e) {
            if (e.keyCode === 90 && e.ctrlKey) {
                if (e.shiftKey) {
                    self.redo();
                } else {
                    self.undo();
                }
                self.render();
            }
        });
    }

    this.lastMovement = [null, null];
    this.translateEventListener('onmousemove');
    this.translateEventListener('onmousedown');
    this.translateEventListener('onmouseup');
    this.translateEventListener('onclick');

    this.updateDimensions();
    setTimeout(this.render.bind(this), 1);

    this.debug = {};
};

Matrix.prototype.translateEventListener = function(eventName) {
    var self = this;
    this.canvas[eventName] = function(e) {
        if (self[eventName]) {
            e.col = self.xToCol(e.clientX);
            e.row = self.yToRow(e.clientY);
            e.cell = self.isValid(e.row, e.col) ? self.board[e.row][e.col] : undefined;
            if (eventName == 'onmousemove') {
                if (e.row == self.lastMovement[0] && e.col == self.lastMovement[1]) {
                    return;
                } else {
                    self.lastMovement = [e.row, e.col];
                }
            }
            self[eventName](e);
            self.render();
        }
    };
}

Matrix.prototype.isValid = function(row, col) {
    return row >= 0 && row < this.height && col >= 0 && col < this.height;
};

Matrix.prototype.xToCol = function(x) {
    return Math.round((x - this.canvas.width/2) / this.cellSpace + this.width/2 - 0.5);
};

Matrix.prototype.yToRow = function(y) {
    return Math.round((y - this.canvasPadding) / this.cellSpace - 0.5);
};

Matrix.prototype.resize = function() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
};

Matrix.prototype.updateDimensions = function() {
    this.width = this.board[0].length;
    this.height = this.board.length;

    this.canvasPadding = this.canvas.height / 20;
    this.cellSpace = Math.min((this.canvas.width - 2*this.canvasPadding) / this.width, (this.canvas.height - 2*this.canvasPadding) / this.height);
    if (this.cellSpace > 10) {
        this.cellPadding = Math.max(1, this.cellSpace / 20);
    } else {
        this.cellPadding = 0;
    }
    this.cellBorder = this.cellSpace / 5;
    this.cellSize = this.cellSpace - this.cellPadding * 2;
};

Matrix.prototype.render = function () {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    this.context.save();
    for (var col = 0; col < this.width; col++) {
        var x = this.canvas.width/2 + (col-this.width/2)*this.cellSpace;

        for (var row = 0; row < this.height; row++) {
            var y = this.canvasPadding + row * this.cellSpace;

            var cell = this.board[row][col];

            if (cell.background !== 0) {
                var fillStyle = this.backgrounds[cell.background];
                this.context.fillStyle = fillStyle;
                this.context.fillRect(x, y - this.cellPadding,
                                 this.cellSpace, this.cellSpace);
            }

            if (cell.type !== 0) {
                var fillStyle = this.fillStyles[cell.type];
                
                this.context.fillStyle = fillStyle;
                this.context.fillRect(x + this.cellPadding, y,
                                 this.cellSize, this.cellSize);
                if (this.cellSpace > 10) {
                    this.context.strokeStyle = this.borderStyle;
                    this.context.strokeRect(x + this.cellPadding, y,
                                       this.cellSize, this.cellSize);
                }
            }

            if (cell.primarySelection) {
                this.context.fillStyle = this.selectionStyle[cell.primarySelection];
                this.context.beginPath();
                this.context.moveTo(x+this.cellBorder+this.cellPadding, y+this.cellBorder);
                this.context.lineTo(x+this.cellSize-this.cellBorder+this.cellPadding, y+this.cellBorder);
                this.context.lineTo(x+this.cellBorder+this.cellPadding, y+this.cellSize-this.cellBorder);
                this.context.fill();
            }
            if (cell.secondarySelection) {
                this.context.fillStyle = this.selectionStyle[cell.secondarySelection];
                this.context.beginPath();
                this.context.moveTo(x+this.cellPadding+this.cellSize-this.cellBorder, y+this.cellSize-this.cellBorder);
                this.context.lineTo(x+this.cellPadding+this.cellSize-this.cellBorder, y+this.cellBorder);
                this.context.lineTo(x+this.cellPadding+this.cellBorder, y+this.cellSize-this.cellBorder);
                this.context.fill();
            }
        }
    }
    this.context.restore();

    this.context.save();
    this.context.fillStyle = '#CCC';
    this.context.font = '16px Verdana';
    this.context.textAlign = 'right';
    var yStart = 20;
    var xStart = this.canvas.width - 10;
    for (var prop in this.debug) {
        this.context.fillText(prop + ": " + this.debug[prop], xStart, yStart);
        yStart += 20;
    }
    this.context.restore();
};

Matrix.prototype.forEach = function(fn) {
    for (var row = 0; row < this.height; row++) {
        for (var col = 0; col < this.width; col++) {
            fn(this.board[row][col]);
        }
    }
};

Matrix.prototype.clear = function(defaultType) {
    this.board = [];
    defaultType = defaultType === undefined ? 0 : defaultType;
    for (var row = 0; row < this.height; row++) {
        var line = [];
        this.board.push(line);
        for (var col = 0; col < this.width; col++) {
            line.push(new Cell(row, col, defaultType));
        }
    }
};

Matrix.prototype.clearSelection = function() {
    this.forEach(function(cell) {
        cell.primarySelection = 0;
        cell.secondarySelection = 0;
    });
};

Matrix.prototype.save = function() {
    var backup = [];
    for (var row = 0; row < this.height; row++) {
        var line = [];
        backup.push(line);
        for (var col = 0; col < this.width; col++) {
            var backupCell = new Cell();
            var cell = this.board[row][col];
            for (var prop in cell) {
                backupCell[prop] = cell[prop];
            }
            line.push(backupCell);
        }
    }

    this.history.push(backup);
    this.future = [];
};

Matrix.prototype.undo = function() {
    if (this.history.length) {
        this.future.push(this.board);
        this.board = this.history.pop();
    } else {
        throw "No more history available for undo.";
    }
};

Matrix.prototype.redo = function() {
    if (this.future.length) {
        this.history.push(this.board);
        this.board = this.future.pop();
    } else {
        throw "No more history available for redo.";
    }    
};
        </script>




        <script>
function initMatrix() {
    matrix.forEach(function(cell) {
        cell.isActive = cell.row === cell.col;
        cell.isCorrect = cell.isActive;
        cell.background = cell.col % 32 == 0 || cell.row % 32 == 0 ? 1 : 0;
    })
;    updateIsCorrect();
    updateTypes();
}

function updateTypes() {
    var m = coeffs[0];
    matrix.forEach(function(cell) {
        if (cell.isCorrect) {
            cell.type = cell.isActive ? 1 : 2;
        } else {
            cell.type = cell.isActive ? 3 : 0;
        }
    });
}

function updateIsCorrect() {
    matrix.forEach(function(cell) {
        cell.isActive = cell.row === cell.col;
        cell.isCorrect = cell.isActive;
    });

    var m = coeffs[0];
    var others = coeffs.slice(1);
    for (var i = m-2; i >= 0; i--) {
        for (var ci = 0; ci < others.length; ci++) {
            var c = others[ci];
            for (var j = m; j < matrix.height; j++) {
                matrix.board[j][c+i].isCorrect ^= matrix.board[j][m+i].isCorrect
            }
        }
    }

    matrix.debug['cellCount'] = 0;
    matrix.forEach(function(cell) {
        if (cell.isCorrect && cell.col < m && cell.row >= m) {
            matrix.debug['cellCount']++;
        }
    });
}

var hash = window.location.hash;
var coeffs;
if (hash) {
    coeffs = window.location.hash.slice(1).split(',').map(Number);
} else {
    coeffs = [20, 15, 10, 5, 0];
}
coeffs = coeffs.sort(function(a,b){return b - a});

var matrix;
function createMatrix() {
    matrix = new Matrix(coeffs[0]*2-1, coeffs[0]*2-1);
    matrix.debug.count = 0;
    initMatrix();
}
createMatrix();


var selectedCoeff = 1;
canvas.onwheel = function(e) {
    var delta = (e.deltaY || e.deltaX) < 0 ? 1 : -1;
    if (e.shiftKey) {
        selectedCoeff = Math.min(Math.max(0, selectedCoeff - delta), coeffs.length - 1);
    } else {
        var n = coeffs[selectedCoeff] + delta;
        var lowerBound = coeffs[selectedCoeff+1] + 1 || 0;
        var upperBound = coeffs[selectedCoeff-1] - 1 || Infinity;
        coeffs[selectedCoeff] = Math.min(Math.max(n, lowerBound), upperBound);
        if (selectedCoeff === 0) {
            createMatrix();
        }
    }
    var letters = "mabcdefghijkl";
    var debug = {};
    for (var i = 0; i < coeffs.length; i++) {
        if (i === selectedCoeff) {
            debug['*' + letters[i]] = coeffs[i];
        } else {
            debug[letters[i]] = coeffs[i];
        }
        
    }
    matrix.debug = debug;
    initMatrix();
    matrix.render();
}
canvas.addEventListener('keydown', function(e) {
    if (e.keyCode === 27) {
        selectionStart = null;
        selectionEnd = null;
        matrix.clearSelection();
        matrix.render();
    }
});

function isInRange(value, start, end) {
    return value >= Math.min(start, end) && value <= Math.max(start, end);
}

function findSrc(cell, srcStart, srcEnd, targetStart) {
    var targetCol = cell.col - (targetStart - srcEnd);
    if (isInRange(targetCol, srcStart, srcEnd)) {
        return matrix.board[cell.row][targetCol];
    } else {
        return null;
    }    
}

function applyMerge(srcStart, srcEnd, targetStart) {
    matrix.forEach(function(cell) {
        var src = findSrc(cell, srcStart, srcEnd, targetStart);
        if (src) {
            cell.isActive ^= src.isActive;
        }
    });
}

var selectionStart = null;
var selectionEnd = null;
var isSelecting = false;
matrix.onmousedown = function(e) {
    selectionStart = e.cell;
    selectionEnd = e.cell;
    isSelecting = true;
    updateSelection();
}
matrix.onmousemove = function(e) {
    if (isSelecting && e.cell) {
        selectionEnd = e.cell;
        updateSelection();
    }
}
matrix.onmouseup = function(e) {
    if (isSelecting && e.cell) {
        selectionEnd = e.cell;
        updateSelection();
        isSelecting = false;
        highlightDuplicates();
    }
}

function forEachSelected(callback) {
    var width = selectionEnd.col - selectionStart.col;
    var height = selectionEnd.row - selectionStart.row;
    var thickness = height - width;
    for (var j = 0; j <= width; j++) {
        for (var i = j; i <= j + thickness; i++) {
            var cell = matrix.board[i + selectionStart.row][j + selectionStart.col];
            if (!callback(cell)) {
                return false;
            }
        }
    }
    return true;
}

function updateSelection() {
    matrix.clearSelection();
    forEachSelected(function(cell) {
        cell.primarySelection = cell.type ? 1 : 2;
        return true;
    });
}

function isDuplicate(distance) {
    return forEachSelected(function(originalCell) {
        if (!originalCell.type)
            return true;

        var parallelCell = matrix.board[originalCell.row][originalCell.col + distance];
        return originalCell.primarySelection !== 1 || parallelCell.type !== 0;
    });
}

function highlightDuplicates() {
    for (var col = 0; col < matrix.width; col++) {
        var distance = col - selectionStart.col;
        if (distance != 0 && isDuplicate(distance)) {
            var width = Math.min(selectionEnd.col - selectionStart.col, matrix.width - col);
            //applyMerge(selectionStart.col, (selectionStart.col + width), col);
            var srcStart = selectionStart.col;
            var srcEnd = selectionStart.col + width;
            var dstStart = col;
            var dstEnd = col + width;
            console.log('C[' + dstStart + ':' + dstEnd + '] ^= C[' + srcStart + ':' + srcEnd + ']');

            forEachSelected(function(originalCell) {
                if (!originalCell.type || originalCell.col + distance >= matrix.width)
                    return true;

                var parallelCell = matrix.board[originalCell.row][originalCell.col + distance];
                parallelCell.secondarySelection = originalCell.type ? 1 : 0;
                return true;
            });
        }
    }
}
        </script>



        <script>
function rangemap(n, fn) {
    var result = [];
    for (var i = 0; i < n; i++) {
        fn(i, result.push.bind(result));
    }
    return result;
}

function runUserAlgorithm() {
    var C = [];
    var W = [];
    var wordSize = 32;

    matrix.debug['bit xors'] = 0;
    matrix.debug['word xors'] = 0;
    matrix.debug['shifts'] = 0;
    matrix.debug['masks'] = 0;

    function makeColumn(a) {
        a.xor = function(b) {
            matrix.debug['bit xors']++;
            return makeColumn(rangemap(matrix.height, function(i, push) {
                if ((a.indexOf(i) !== -1) ^ (b.indexOf(i) !== -1)) {
                    push(i);
                }
            }));
        }
        return a;
    }

    function makeWordColumn(wa) {
        wa.xor = function(wb) {
            matrix.debug['word xors']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(wa[i].xor(wb[i]));
            }));
        }
        wa.lshift = function(n) {
            matrix.debug['shifts']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(i < n ? makeColumn([]) : wa[i-n]);
            }));
        }
        wa.rshift = function(n) {
            matrix.debug['shifts']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(i + n >= wa.length ? makeColumn([]) : wa[i+n]);
            }));
        }
        wa.mask = function(mask) {
            matrix.debug['masks']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(Math.pow(2, i) & mask ? wa[i] : makeColumn([]));
            }));
        }
        return wa;
    }

    // Divide rows into columns and those columns into words.
    for (var col = 0; col < matrix.width; col++) {
        C[col] = makeColumn([col]);
        if (col % wordSize == 0) {
            W.push(makeWordColumn([]))
        }
        W[W.length-1].push(C[col])
    }
    // Add empty columns to the last word to ensure size regularity.
    for (var i = matrix.width % 32; i < 32; i++) {
        W[W.length-1].push([])
    }

    var code = document.getElementById('user-algorithm').value;
    code = code.replace(/\/\*.*?\*\//g, '');
    code = code.replace(/(\w+(?:\[\d+\])?)\s*(\^|<<|>>|&)=/g, '$1 = $1 $2 ');
    code = code.replace(/\s*\^\s*(.+?);?$/gm, '.xor($1)');
    code = code.replace(/\s*<<\s*(\d+)/g, '.lshift($1)');
    code = code.replace(/\s*>>\s*(\d+)/g, '.rshift($1)');
    code = code.replace(/\s*&\s*(\w+)/g, '.mask($1)');
    console.log(code);
    eval(code);

    var isWordOriented = code.indexOf('W[') != -1;

    for (var col = 0; col < matrix.width; col++) {
        for (var row = 0; row < matrix.height; row++) {
            if (isWordOriented) {
                matrix.board[row][col].isActive = W[(col/32)|0][col%32].indexOf(row) != -1;
            } else {
                matrix.board[row][col].isActive = C[col].indexOf(row) != -1;
            }
        }
    }

    matrix.debug['total word op'] = matrix.debug['word xors'] + matrix.debug['shifts'] + matrix.debug['masks'];

    updateTypes();
    matrix.render();
}

function makeBitAlgorithm() {
    var code = []
    var m = (matrix.width + 2) / 2;
    for (var col = 0; col < matrix.width; col++) {
        for (var row = 0; row < matrix.height; row++) {
            if (matrix.board[row][col].isCorrect && col < m && row != col) {
                code.push('C[' + col + '] ^= C[' + row + ']');
            }
        }
    }
    document.getElementById('user-algorithm').value = code.join('\n');
}
function findCorrectRanges() {
    var m = (matrix.width + 1) / 2;
    var ranges = [];

    function isCorrect(row, col) {
        return row != col && col < m && row < matrix.height && col < matrix.width && matrix.board[row][col].isCorrect;
    }

    for (var blockCol = 0; blockCol < (matrix.width + 2) / 2; blockCol += 32) {
        for (var blockRow = 0; blockRow < matrix.height; blockRow += 32) {

            for (var colStart = -32; colStart < 32; colStart++) {
                var startRange = -1;
                for (var t = Math.max(0, -colStart); t < 32; t++) {
                    var subRow = 0 + t;
                    var subCol = colStart + t;
                    if (isCorrect(blockRow + subRow, blockCol + subCol)) {
                        if (startRange === -1) {
                            startRange = t;
                        }
                        if (!isCorrect(blockRow + subRow + 1, blockCol + subCol + 1) || t == 31) {
                            var isStartFull = startRange == 0 || startRange == -colStart;
                            var isEndFull = t == 31 || t == 31 - colStart || blockRow + subRow == matrix.height - 1;
                            ranges.push({
                                'blockCol': blockCol,
                                'blockRow': blockRow,
                                'colStart': colStart,
                                'isFull': isStartFull && isEndFull,
                                'range': [startRange, t+1],
                            });
                        }
                    }
                }
            }
        }
    }

    return ranges;
}
function repeatStr(str, n) {
    var result = '';
    for (var i = 0; i < n; i++) {
        result += str;
    }
    return result;
}
function makeWordAlgorithm() {
    var code = []
    var temporary = {};
    function temp(exp, line) {
        if (temporary[exp]) {
            temporary[exp].push(line);
        } else {
            temporary[exp] = [line];
        }
    }

    var ranges = findCorrectRanges();

    for (var j = 0; j < ranges.length; j++) {
        var r = ranges[j];
        var prefix = 'W[' + (r.blockCol/32) + '] ^= ';
        var suffix = 'W[' + (r.blockRow/32) + ']';

        if (!r.isFull) {
            var length = r.range[1] - r.range[0];
            if (r.range[1] == 31) {
                length = 32;
            }
            suffix += ' & 0b' + repeatStr('1', length) + repeatStr('0', r.range[0]);
            temp(suffix, code.length);
        }

        if (r.colStart) {
            suffix += (r.colStart > 0 ? ' << ' : ' >> ') + Math.abs(r.colStart);
            temp(suffix, code.length);
        }
        code.push(prefix + suffix);
    }

    var temporaryAssignments = [];
    var count = 0;
    for (var dup in temporary) {
        var lines = temporary[dup];
        if (lines.length === 1) {
            continue;
        }
        temporaryAssignments.push('temp' + count + ' = ' + dup);

        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            code[line] = code[line].replace(dup, 'temp' + count)
        }
        count++;
    }
    document.getElementById('user-algorithm').value = temporaryAssignments.concat(code).join('\n');
}
makeWordAlgorithm();
        </script>
    </body>
</html>