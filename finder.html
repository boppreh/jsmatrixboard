<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <title>Matrix Board Test</title>
        <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font: 16px sans-serif;
            color: #CCC;
        }
        canvas {
            background-color: #EEE;
            width: 100%;
            height: 100%;
            background-color: #456990;
        }
        #input-div {
            padding: 10px;
            position: fixed;
            background-color: #426487;
            display: flex;
            flex-direction: column;
            /*visibility: hidden;*/
        }
        </style>
    </head>
    <body>
        <div id="input-div">
            <textarea cols=60 rows=15 id="user-algorithm"></textarea>
            <div id="start-controls">
                <button onclick="runUserAlgorithm();">Apply</button>
            </div>
            <div id="running-controls" style="display: none;">
                <button id="btn-play-pause" onclick="playPauseUserAlgorithm();">Pause</button>
                <button onclick="running = true; stepUserAlgorithm(); running=false;">Step</button>
                <button onclick="stopUserAlgorithm();">Stop</button>
            </div>
        </div>
        <canvas></canvas>
        <script src="matrixboard.js" type="text/javascript"></script>

        <script>
function initMatrix() {
    matrix.forEach(function(cell) {
        cell.isActive = cell.row === cell.col;
        cell.isCorrect = cell.isActive;
        cell.background = cell.col % 32 == 0 || cell.row % 32 == 0 ? 1 : 0;
    })
;    updateIsCorrect();
    updateTypes();
}

function updateTypes() {
    var m = coeffs[0];
    matrix.forEach(function(cell) {
        if (cell.isCorrect) {
            cell.type = cell.isActive ? 1 : 2;
        } else {
            cell.type = cell.isActive ? 3 : 0;
        }
    });
}

function updateIsCorrect() {
    matrix.forEach(function(cell) {
        cell.isActive = cell.row === cell.col;
        cell.isCorrect = cell.isActive;
    });

    var m = coeffs[0];
    var others = coeffs.slice(1);
    for (var i = m-2; i >= 0; i--) {
        for (var ci = 0; ci < others.length; ci++) {
            var c = others[ci];
            for (var j = m; j < matrix.height; j++) {
                matrix.board[j][c+i].isCorrect ^= matrix.board[j][m+i].isCorrect
            }
        }
    }

    matrix.debug['cellCount'] = 0;
    matrix.forEach(function(cell) {
        cell.isCorrect &= cell.col < m;
        if (cell.isCorrect && cell.col < m && cell.row >= m) {
            matrix.debug['cellCount']++;
        }
    });
}

var hash = window.location.hash;
var coeffs;
if (hash) {
    coeffs = window.location.hash.slice(1).split(',').map(Number);
} else {
    coeffs = [20, 15, 10, 5, 0];
}
coeffs = coeffs.sort(function(a,b){return b - a});

var matrix;
function createMatrix() {
    matrix = new Matrix(coeffs[0]*2-1, coeffs[0]*2-1);
    matrix.debug.count = 0;
    initMatrix();
}
createMatrix();
        </script>



        <script>
function rangemap(n, fn) {
    var result = [];
    var push = result.push.bind(result);
    for (var i = 0; i < n; i++) {
        fn(i, push);
    }
    return result;
}

function runUserAlgorithm() {
    var C = [];
    var W = [];
    var wordSize = 32;

    matrix.debug['bit xors'] = 0;
    matrix.debug['word xors'] = 0;
    matrix.debug['shifts'] = 0;
    matrix.debug['masks'] = 0;

    function makeColumn(a) {
        a.xor = function(b) {
            matrix.debug['bit xors']++;
            return makeColumn(rangemap(matrix.height, function(i, push) {
                if ((a.indexOf(i) !== -1) ^ (b.indexOf(i) !== -1)) {
                    push(i);
                }
            }));
        }
        return a;
    }

    function makeWordColumn(wa) {
        wa.xor = function(wb) {
            matrix.debug['word xors']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                if (wa[i] === undefined) {
                    console.log(wa, i)
                }
                push(wa[i].xor(wb[i]));
            }));
        }
        wa.lshift = function(n) {
            matrix.debug['shifts']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(i < n ? makeColumn([]) : wa[i-n]);
            }));
        }
        wa.rshift = function(n) {
            matrix.debug['shifts']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(i + n >= wa.length ? makeColumn([]) : wa[i+n]);
            }));
        }
        wa.mask = function(mask) {
            matrix.debug['masks']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(Math.pow(2, i) & mask ? wa[i] : makeColumn([]));
            }));
        }
        return wa;
    }

    // Divide rows into columns and those columns into words.
    for (var col = 0; col < matrix.width; col++) {
        C[col] = makeColumn([col]);
        if (col % wordSize == 0) {
            W.push(makeWordColumn([]))
        }
        W[W.length-1].push(C[col])
    }
    // Add empty columns to the last word to ensure size regularity.
    for (var i = matrix.width % 32; i < 32; i++) {
        W[W.length-1].push(makeColumn([]))
    }

    var code = document.getElementById('user-algorithm').value;
    code = code.replace(/\/\*.*?\*\//g, '');
    code = code.replace(/(\w+(?:\[.+?\])?)\s*(\^|<<|>>|&)=/g, '$1 = $1 $2 ');
    console.log(code)
    code = code.replace(/\s*\^\s*\(/g, '.xor(');
    code = code.replace(/\s*\^\s*(.+?);?$/gm, '.xor($1)');
    code = code.replace(/\s*<<\s*(\d+)/g, '.lshift($1)');
    code = code.replace(/\s*>>\s*(\d+)/g, '.rshift($1)');
    code = code.replace(/\s*&\s*(\w+)/g, '.mask($1)');
    console.log(code);
    eval(code);

    var isWordOriented = code.indexOf('W[') != -1;

    for (var col = 0; col < matrix.width; col++) {
        for (var row = 0; row < matrix.height; row++) {
            if (isWordOriented) {
                matrix.board[row][col].isActive = W[(col/32)|0][col%32].indexOf(row) != -1;
            } else {
                matrix.board[row][col].isActive = C[col].indexOf(row) != -1;
            }
        }
    }

    matrix.debug['total word op'] = matrix.debug['word xors'] + matrix.debug['shifts'] + matrix.debug['masks'];

    updateTypes();
    matrix.render();
}

function makeBitAlgorithm() {
    var code = []
    var m = (matrix.width + 2) / 2;
    for (var col = 0; col < matrix.width; col++) {
        for (var row = 0; row < matrix.height; row++) {
            if (matrix.board[row][col].isCorrect && col < m && row != col) {
                code.push('C[' + col + '] ^= C[' + row + ']');
            }
        }
    }
    document.getElementById('user-algorithm').value = code.join('\n');
}
function findCorrectXorPairs() {
    var m = (matrix.width + 1) / 2;

    function isCorrect(row, col) {
        return row != col && col < m && row < matrix.height && col < matrix.width && matrix.board[row][col].isCorrect;
    }

    var columns = {};
    for (var blockCol = 0; blockCol < (matrix.width + 2) / 2; blockCol += 32) {
        for (var blockRow = 0; blockRow < matrix.height; blockRow += 32) {

            for (var colStart = -32; colStart < 32; colStart++) {
                var startRange = -1;
                for (var t = Math.max(0, -colStart); t < 32; t++) {
                    var subRow = 0 + t;
                    var subCol = colStart + t;
                    if (isCorrect(blockRow + subRow, blockCol + subCol)) {
                        if (startRange === -1) {
                            startRange = t;
                        }
                        if (!isCorrect(blockRow + subRow + 1, blockCol + subCol + 1) || t == 31) {
                            var isStartFull = startRange == 0 || startRange == -colStart;
                            var isEndFull = t == 31 || t == 31 - colStart || blockRow + subRow == matrix.height - 1;
                            var diag = {
                                'blockCol': blockCol,
                                'blockRow': blockRow,
                                'colStart': colStart,
                                'isFull': isStartFull && isEndFull,
                                'range': [startRange, t+1],
                                'column': startColumn,
                            };
                            var startColumn = blockCol + startRange + colStart;
                            if (columns[startColumn] === undefined) {
                                columns[startColumn] = [];
                            }
                            columns[startColumn].push(diag);
                            diag.column = columns[startColumn];
                        }
                    }
                }
            }
        }
    }

    var allPairs = {}
    for (var colNumber in columns) {
        var column = columns[colNumber]
        var minColStart = Infinity;
        for (var j = 0; j < column.length; j++) {
            var diag = column[j];
            minColStart = Math.min(minColStart, diag.colStart);
        }
        for (var j = 0; j < column.length; j++) {
            column[j].minColStart = minColStart;
            for (var k = 0; k < j; k++) {
                var info = [column[k].blockRow/32, column[k].colStart-minColStart,
                            column[j].blockRow/32, column[j].colStart-minColStart];
                if (allPairs[info] === undefined) {
                    allPairs[info] = [];
                    // Save for later because JS dictionaries convert keys to strings.
                    allPairs[info].info = info
                }
                allPairs[info].push([column[j], column[k]]);
            }
        }
    }

    return allPairs;
}
function repeatStr(str, n) {
    var result = '';
    for (var i = 0; i < n; i++) {
        result += str;
    }
    return result;
}
function makeWordAlgorithm() {
    var code = [];
    var allPairs = findCorrectXorPairs();
    for (var key in allPairs) {
        var a = allPairs[key][0][0];
        var b = allPairs[key][0][1];
        var tempName = 'temp_' + key.replace(/,/g, '_')
        code.push(tempName + ' = (W[' + a.blockRow/32 + ']<<' + (a.colStart-a.minColStart) + ') ^ ' + '(W[' + b.blockRow/32 + ']<<' + (b.colStart-b.minColStart) + ')');

        var pairs = allPairs[key];
        for (var i = 0; i < pairs.length; i++) {
            var a = pairs[i][0];
            var shift = a.minColStart;
            code.push('W[' + a.blockCol/32 + '] ^= ' + tempName + (shift > 0 ? ' << ' : ' >> ') + Math.abs(shift));
        }
    }

    document.getElementById('user-algorithm').value = code.join('\n');
}
makeWordAlgorithm();
        </script>
    </body>
</html>