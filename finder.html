<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <title>Matrix Board Test</title>
        <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font: 16px sans-serif;
            color: #CCC;
        }
        canvas {
            background-color: #EEE;
            width: 100%;
            height: 100%;
            background-color: #456990;
        }
        #input-div {
            padding: 10px;
            position: fixed;
            background-color: #426487;
            display: flex;
            flex-direction: column;
            /*visibility: hidden;*/
        }
        </style>
    </head>
    <body>
        <div id="input-div">
            <textarea cols=60 rows=15 id="user-algorithm"></textarea>
            <div id="start-controls">
                <button onclick="runUserAlgorithm();">Apply</button>
            </div>
            <div id="running-controls" style="display: none;">
                <button id="btn-play-pause" onclick="playPauseUserAlgorithm();">Pause</button>
                <button onclick="running = true; stepUserAlgorithm(); running=false;">Step</button>
                <button onclick="stopUserAlgorithm();">Stop</button>
            </div>
        </div>
        <canvas></canvas>
        <script src="matrixboard.js" type="text/javascript"></script>

        <script>
function initMatrix() {
    matrix.forEach(function(cell) {
        cell.isActive = cell.row === cell.col;
        cell.isCorrect = cell.isActive;
        cell.background = cell.col % 32 == 0 || cell.row % 32 == 0 ? 1 : 0;
    })
;    updateIsCorrect();
    updateTypes();
}

function updateTypes() {
    var m = coeffs[0];
    matrix.forEach(function(cell) {
        if (cell.isCorrect) {
            cell.type = cell.isActive ? 1 : 2;
        } else {
            cell.type = cell.isActive ? 3 : 0;
        }
    });
}

function updateIsCorrect() {
    matrix.forEach(function(cell) {
        cell.isActive = cell.row === cell.col;
        cell.isCorrect = cell.isActive;
    });

    var m = coeffs[0];
    var others = coeffs.slice(1);
    for (var i = m-2; i >= 0; i--) {
        for (var ci = 0; ci < others.length; ci++) {
            var c = others[ci];
            for (var j = m; j < matrix.height; j++) {
                matrix.board[j][c+i].isCorrect ^= matrix.board[j][m+i].isCorrect
            }
        }
    }

    matrix.debug['cellCount'] = 0;
    matrix.forEach(function(cell) {
        if (cell.isCorrect && cell.col < m && cell.row >= m) {
            matrix.debug['cellCount']++;
        }
    });
}

var hash = window.location.hash;
var coeffs;
if (hash) {
    coeffs = window.location.hash.slice(1).split(',').map(Number);
} else {
    coeffs = [20, 15, 10, 5, 0];
}
coeffs = coeffs.sort(function(a,b){return b - a});

var matrix;
function createMatrix() {
    matrix = new Matrix(coeffs[0]*2-1, coeffs[0]*2-1);
    matrix.debug.count = 0;
    initMatrix();
}
createMatrix();


var selectedCoeff = 1;
canvas.onwheel = function(e) {
    var delta = (e.deltaY || e.deltaX) < 0 ? 1 : -1;
    if (e.shiftKey) {
        selectedCoeff = Math.min(Math.max(0, selectedCoeff - delta), coeffs.length - 1);
    } else {
        var n = coeffs[selectedCoeff] + delta;
        var lowerBound = coeffs[selectedCoeff+1] + 1 || 0;
        var upperBound = coeffs[selectedCoeff-1] - 1 || Infinity;
        coeffs[selectedCoeff] = Math.min(Math.max(n, lowerBound), upperBound);
        if (selectedCoeff === 0) {
            createMatrix();
        }
    }
    var letters = "mabcdefghijkl";
    var debug = {};
    for (var i = 0; i < coeffs.length; i++) {
        if (i === selectedCoeff) {
            debug['*' + letters[i]] = coeffs[i];
        } else {
            debug[letters[i]] = coeffs[i];
        }
        
    }
    matrix.debug = debug;
    initMatrix();
    matrix.render();
}
canvas.addEventListener('keydown', function(e) {
    if (e.keyCode === 27) {
        selectionStart = null;
        selectionEnd = null;
        matrix.clearSelection();
        matrix.render();
    }
});

function isInRange(value, start, end) {
    return value >= Math.min(start, end) && value <= Math.max(start, end);
}

function findSrc(cell, srcStart, srcEnd, targetStart) {
    var targetCol = cell.col - (targetStart - srcEnd);
    if (isInRange(targetCol, srcStart, srcEnd)) {
        return matrix.board[cell.row][targetCol];
    } else {
        return null;
    }    
}

function applyMerge(srcStart, srcEnd, targetStart) {
    matrix.forEach(function(cell) {
        var src = findSrc(cell, srcStart, srcEnd, targetStart);
        if (src) {
            cell.isActive ^= src.isActive;
        }
    });
}

var selectionStart = null;
var selectionEnd = null;
var isSelecting = false;
matrix.onmousedown = function(e) {
    selectionStart = e.cell;
    selectionEnd = e.cell;
    isSelecting = true;
    updateSelection();
}
matrix.onmousemove = function(e) {
    if (isSelecting && e.cell) {
        selectionEnd = e.cell;
        updateSelection();
    }
}
matrix.onmouseup = function(e) {
    if (isSelecting && e.cell) {
        selectionEnd = e.cell;
        updateSelection();
        isSelecting = false;
        highlightDuplicates();
    }
}

function forEachSelected(callback) {
    var width = selectionEnd.col - selectionStart.col;
    var height = selectionEnd.row - selectionStart.row;
    var thickness = height - width;
    for (var j = 0; j <= width; j++) {
        for (var i = j; i <= j + thickness; i++) {
            var cell = matrix.board[i + selectionStart.row][j + selectionStart.col];
            if (!callback(cell)) {
                return false;
            }
        }
    }
    return true;
}

function updateSelection() {
    matrix.clearSelection();
    forEachSelected(function(cell) {
        cell.primarySelection = cell.type ? 1 : 2;
        return true;
    });
}

function isDuplicate(distance) {
    return forEachSelected(function(originalCell) {
        if (!originalCell.type)
            return true;

        var parallelCell = matrix.board[originalCell.row][originalCell.col + distance];
        return originalCell.primarySelection !== 1 || parallelCell.type !== 0;
    });
}

function highlightDuplicates() {
    for (var col = 0; col < matrix.width; col++) {
        var distance = col - selectionStart.col;
        if (distance != 0 && isDuplicate(distance)) {
            var width = Math.min(selectionEnd.col - selectionStart.col, matrix.width - col);
            //applyMerge(selectionStart.col, (selectionStart.col + width), col);
            var srcStart = selectionStart.col;
            var srcEnd = selectionStart.col + width;
            var dstStart = col;
            var dstEnd = col + width;
            console.log('C[' + dstStart + ':' + dstEnd + '] ^= C[' + srcStart + ':' + srcEnd + ']');

            forEachSelected(function(originalCell) {
                if (!originalCell.type || originalCell.col + distance >= matrix.width)
                    return true;

                var parallelCell = matrix.board[originalCell.row][originalCell.col + distance];
                parallelCell.secondarySelection = originalCell.type ? 1 : 0;
                return true;
            });
        }
    }
}
        </script>



        <script>
function rangemap(n, fn) {
    var result = [];
    for (var i = 0; i < n; i++) {
        fn(i, result.push.bind(result));
    }
    return result;
}

function runUserAlgorithm() {
    var C = [];
    var W = [];
    var wordSize = 32;

    matrix.debug['bit xors'] = 0;
    matrix.debug['word xors'] = 0;
    matrix.debug['shifts'] = 0;
    matrix.debug['masks'] = 0;

    function makeColumn(a) {
        a.xor = function(b) {
            matrix.debug['bit xors']++;
            return makeColumn(rangemap(matrix.height, function(i, push) {
                if ((a.indexOf(i) !== -1) ^ (b.indexOf(i) !== -1)) {
                    push(i);
                }
            }));
        }
        return a;
    }

    function makeWordColumn(wa) {
        wa.xor = function(wb) {
            matrix.debug['word xors']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(wa[i].xor(wb[i]));
            }));
        }
        wa.lshift = function(n) {
            matrix.debug['shifts']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(i < n ? makeColumn([]) : wa[i-n]);
            }));
        }
        wa.rshift = function(n) {
            matrix.debug['shifts']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(i + n >= wa.length ? makeColumn([]) : wa[i+n]);
            }));
        }
        wa.mask = function(mask) {
            matrix.debug['masks']++;
            return makeWordColumn(rangemap(wordSize, function(i, push) {
                push(Math.pow(2, i) & mask ? wa[i] : makeColumn([]));
            }));
        }
        return wa;
    }

    // Divide rows into columns and those columns into words.
    for (var col = 0; col < matrix.width; col++) {
        C[col] = makeColumn([col]);
        if (col % wordSize == 0) {
            W.push(makeWordColumn([]))
        }
        W[W.length-1].push(C[col])
    }
    // Add empty columns to the last word to ensure size regularity.
    for (var i = matrix.width % 32; i < 32; i++) {
        W[W.length-1].push([])
    }

    var code = document.getElementById('user-algorithm').value;
    code = code.replace(/\/\*.*?\*\//g, '');
    code = code.replace(/(\w+(?:\[\d+\])?)\s*(\^|<<|>>|&)=/g, '$1 = $1 $2 ');
    code = code.replace(/\s*\^\s*(.+?);?$/gm, '.xor($1)');
    code = code.replace(/\s*<<\s*(\d+)/g, '.lshift($1)');
    code = code.replace(/\s*>>\s*(\d+)/g, '.rshift($1)');
    code = code.replace(/\s*&\s*(\w+)/g, '.mask($1)');
    console.log(code);
    eval(code);

    var isWordOriented = code.indexOf('W[') != -1;

    for (var col = 0; col < matrix.width; col++) {
        for (var row = 0; row < matrix.height; row++) {
            if (isWordOriented) {
                matrix.board[row][col].isActive = W[(col/32)|0][col%32].indexOf(row) != -1;
            } else {
                matrix.board[row][col].isActive = C[col].indexOf(row) != -1;
            }
        }
    }

    matrix.debug['total word op'] = matrix.debug['word xors'] + matrix.debug['shifts'] + matrix.debug['masks'];

    updateTypes();
    matrix.render();
}

function makeBitAlgorithm() {
    var code = []
    var m = (matrix.width + 2) / 2;
    for (var col = 0; col < matrix.width; col++) {
        for (var row = 0; row < matrix.height; row++) {
            if (matrix.board[row][col].isCorrect && col < m && row != col) {
                code.push('C[' + col + '] ^= C[' + row + ']');
            }
        }
    }
    document.getElementById('user-algorithm').value = code.join('\n');
}
function findCorrectRanges() {
    var m = (matrix.width + 1) / 2;
    var ranges = [];

    function isCorrect(row, col) {
        return row != col && col < m && row < matrix.height && col < matrix.width && matrix.board[row][col].isCorrect;
    }

    for (var blockCol = 0; blockCol < (matrix.width + 2) / 2; blockCol += 32) {
        for (var blockRow = 0; blockRow < matrix.height; blockRow += 32) {

            for (var colStart = -32; colStart < 32; colStart++) {
                var startRange = -1;
                for (var t = Math.max(0, -colStart); t < 32; t++) {
                    var subRow = 0 + t;
                    var subCol = colStart + t;
                    if (isCorrect(blockRow + subRow, blockCol + subCol)) {
                        if (startRange === -1) {
                            startRange = t;
                        }
                        if (!isCorrect(blockRow + subRow + 1, blockCol + subCol + 1) || t == 31) {
                            var isStartFull = startRange == 0 || startRange == -colStart;
                            var isEndFull = t == 31 || t == 31 - colStart || blockRow + subRow == matrix.height - 1;
                            ranges.push({
                                'blockCol': blockCol,
                                'blockRow': blockRow,
                                'colStart': colStart,
                                'isFull': isStartFull && isEndFull,
                                'range': [startRange, t+1],
                            });
                        }
                    }
                }
            }
        }
    }

    return ranges;
}
function repeatStr(str, n) {
    var result = '';
    for (var i = 0; i < n; i++) {
        result += str;
    }
    return result;
}
function makeWordAlgorithm() {
    var code = []
    var temporary = {};
    function temp(exp, line) {
        if (temporary[exp]) {
            temporary[exp].push(line);
        } else {
            temporary[exp] = [line];
        }
    }

    var ranges = findCorrectRanges();

    for (var j = 0; j < ranges.length; j++) {
        var r = ranges[j];
        var prefix = 'W[' + (r.blockCol/32) + '] ^= ';
        var suffix = 'W[' + (r.blockRow/32) + ']';

        if (!r.isFull) {
            var length = r.range[1] - r.range[0];
            var mask = repeatStr('1', length) + repeatStr('0', r.range[0]);
            suffix = '(' + suffix + ' & 0b' + mask + ')';
            temp(suffix, code.length);
        }

        if (r.colStart) {
            suffix += (r.colStart > 0 ? ' << ' : ' >> ') + Math.abs(r.colStart);
            temp(suffix, code.length);
        }
        code.push(prefix + suffix);
    }

    var temporaryAssignments = [];
    var count = 0;
    for (var dup in temporary) {
        var lines = temporary[dup];
        if (lines.length === 1) {
            continue;
        }
        temporaryAssignments.push('temp' + count + ' = ' + dup);

        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            code[line] = code[line].replace(dup, 'temp' + count)
        }
        count++;
    }
    var m = (matrix.width + 1) / 2;
    if (m % 32 != 0) {
        code.push('W[' + ((m/32)|0) + '] &= 0b' + repeatStr('1', m%32));
    }
    document.getElementById('user-algorithm').value = temporaryAssignments.concat(code).join('\n');
}
makeWordAlgorithm();
        </script>
    </body>
</html>